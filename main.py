import logging
import httpx
import os
from enum import Enum
from dotenv import load_dotenv
import threading
from flask import Flask
import asyncio
import random

import firebase_admin
from firebase_admin import credentials, firestore

from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    ConversationHandler,
    Application
)

load_dotenv()
db = None
_initial_fb_logger = logging.getLogger("FIREBASE_INIT_LOGGER")
_initial_fb_logger.setLevel(logging.INFO)
_fb_handler = logging.StreamHandler()
_fb_formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
_fb_handler.setFormatter(_fb_formatter)
if not _initial_fb_logger.hasHandlers():
    _initial_fb_logger.addHandler(_fb_handler)
try:
    cred_path_render = os.getenv("FIREBASE_CREDENTIALS_PATH", "/etc/secrets/firebase-service-account-key.json")
    cred_path_local = "firebase-service-account-key.json"
    cred_path = cred_path_render if os.path.exists(cred_path_render) else cred_path_local
    if not os.path.exists(cred_path):
        _initial_fb_logger.warning(f"ŸÅÿß€åŸÑ ⁄©ŸÑ€åÿØ Firebase ÿØÿ± ŸÖÿ≥€åÿ± '{cred_path}' €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
    else:
        cred = credentials.Certificate(cred_path)
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
        db = firestore.client()
        _initial_fb_logger.info("Firebase Admin SDK ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ŸÖŸÇÿØÿßÿ±ÿØŸá€å ÿßŸàŸÑ€åŸá ÿ¥ÿØ.")
except Exception as e:
    _initial_fb_logger.error(f"ÿÆÿ∑ÿß€å ÿ®ÿ≠ÿ±ÿßŸÜ€å ÿØÿ± ŸÖŸÇÿØÿßÿ±ÿØŸá€å ÿßŸàŸÑ€åŸá Firebase: {e}", exc_info=True)

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
    handlers=[logging.StreamHandler()],
    force=True
)
logger = logging.getLogger(__name__)
logger.info("ÿßÿ≥⁄©ÿ±€åŸæÿ™ main.py ÿ¥ÿ±Ÿàÿπ ÿ®Ÿá ⁄©ÿßÿ± ⁄©ÿ±ÿØ...")

TELEGRAM_TOKEN = os.getenv("BOT_TOKEN")
OPENROUTER_API_KEY = os.getenv("OPENROUTER_API_KEY")
OPENROUTER_MODEL_NAME = os.getenv("OPENROUTER_MODEL_NAME", "openai/gpt-3.5-turbo")
WELCOME_IMAGE_URL = os.getenv("WELCOME_IMAGE_URL", "https://tafteh.ir/wp-content/uploads/2024/12/navar-nehdashti2-600x600.jpg")
URL_TAFTEH_WEBSITE = "https://tafteh.ir/"

POINTS_FOR_JOINING_CLUB = 50
# POINTS_FOR_PROFILE_COMPLETION (ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™) ÿ≠ÿ∞ŸÅ ÿ¥ÿØ
POINTS_FOR_FULL_PROFILE_COMPLETION = 30 # ÿßŸÖÿ™€åÿßÿ≤ ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ÿ™⁄©ŸÖ€åŸÑ ŸÜÿßŸÖÿå ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€åÿå ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™
# POINTS_FOR_CLUB_TIP ÿ≠ÿ∞ŸÅ ÿ¥ÿØ

BADGE_CLUB_MEMBER = "ÿπÿ∂Ÿà ÿ®ÿßÿ¥⁄ØÿßŸá ÿ™ÿßŸÅÿ™Ÿá üèÖ"
# BADGE_PROFILE_COMPLETE (ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™) ÿ≠ÿ∞ŸÅ ÿ¥ÿØ
BADGE_FULL_PROFILE = "Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿ∑ŸÑÿß€å€å ‚ú®" # ÿ®ÿ±ÿß€å ŸÜÿßŸÖÿå ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€åÿå ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™
BADGE_HEALTH_EXPLORER = "⁄©ÿßÿ¥ŸÅ ÿ≥ŸÑÿßŸÖÿ™ üß≠"
CLUB_TIP_BADGE_THRESHOLD = 3

if not TELEGRAM_TOKEN or not OPENROUTER_API_KEY:
    logger.error("!!! ÿ®ÿ≠ÿ±ÿßŸÜ€å: ÿ™Ÿà⁄©ŸÜ‚ÄåŸáÿß€å ÿ∂ÿ±Ÿàÿ±€å ÿ±ÿ®ÿßÿ™ €åÿß API €åÿßŸÅÿ™ ŸÜÿ¥ÿØŸÜÿØ.")
    exit(1)
else:
    logger.info("ÿ™Ÿà⁄©ŸÜ ÿ±ÿ®ÿßÿ™ Ÿà ⁄©ŸÑ€åÿØ API ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØŸÜÿØ.")

class States(Enum):
    MAIN_MENU = 1
    AWAITING_PROFILE_FIRST_NAME = 10 # ÿ¥ÿ±Ÿàÿπ ÿ¨ÿ±€åÿßŸÜ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ
    AWAITING_PROFILE_LAST_NAME = 11
    AWAITING_PROFILE_AGE = 12
    AWAITING_PROFILE_GENDER = 13
    AWAITING_DOCTOR_AGE = 2 # ŸÇÿ®ŸÑÿß AWAITING_AGE ÿ®ŸàÿØÿå ÿ®ÿ±ÿß€å ÿ™ŸÅ⁄©€å⁄© ÿ™ÿ∫€å€åÿ± ŸÜÿßŸÖ ÿØÿßÿØ€åŸÖ
    AWAITING_DOCTOR_GENDER = 3 # ŸÇÿ®ŸÑÿß AWAITING_GENDER ÿ®ŸàÿØ
    DOCTOR_CONVERSATION = 4
    AWAITING_CLUB_JOIN_CONFIRMATION = 5
    PROFILE_VIEW = 6
    AWAITING_CANCEL_MEMBERSHIP_CONFIRMATION = 7
    AWAITING_EDIT_FIRST_NAME = 8 # ŸÇÿ®ŸÑÿß AWAITING_FIRST_NAME ÿ®ŸàÿØ
    AWAITING_EDIT_LAST_NAME = 9  # ŸÇÿ®ŸÑÿß AWAITING_LAST_NAME ÿ®ŸàÿØ


# --- ÿ™ÿπÿ±€åŸÅ ⁄©€åÿ®Ÿàÿ±ÿØŸáÿß ---
DOCTOR_CONVERSATION_KEYBOARD = ReplyKeyboardMarkup(
    [["‚ùì ÿ≥ŸàÿßŸÑ ÿ¨ÿØ€åÿØ ÿßÿ≤ ÿØ⁄©ÿ™ÿ±"], ["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å"]], resize_keyboard=True
)
# ⁄©€åÿ®Ÿàÿ±ÿØ ÿ®ÿ±ÿß€å ÿ™ŸÖÿßŸÖ ŸÖÿ±ÿßÿ≠ŸÑ Ÿàÿ±ŸàÿØ ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿæÿ±ŸàŸÅÿß€åŸÑ (ŸÜÿßŸÖÿå ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€åÿå ÿ≥ŸÜÿå ÿ¨ŸÜÿ≥€åÿ™)
PROFILE_INPUT_BACK_KEYBOARD = ReplyKeyboardMarkup(
    [["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å"]], resize_keyboard=True, one_time_keyboard=True
)
# ⁄©€åÿ®Ÿàÿ±ÿØ ÿ®ÿ±ÿß€å ŸÖÿ±ÿ≠ŸÑŸá ÿßŸÜÿ™ÿÆÿßÿ® ÿ¨ŸÜÿ≥€åÿ™ ÿØÿ± ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ
PROFILE_GENDER_SELECTION_KEYBOARD = ReplyKeyboardMarkup(
    [["ÿ≤ŸÜ"], ["ŸÖÿ±ÿØ"], ["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å"]], resize_keyboard=True, one_time_keyboard=True
)
CLUB_JOIN_CONFIRMATION_KEYBOARD = ReplyKeyboardMarkup(
    [["‚úÖ ÿ®ŸÑŸáÿå ÿπÿ∂Ÿà ŸÖ€å‚Äåÿ¥ŸàŸÖ"], ["‚ùå ÿÆ€åÿ±ÿå ŸÅÿπŸÑÿßŸã ŸÜŸá"]], resize_keyboard=True, one_time_keyboard=True
)
PROFILE_VIEW_KEYBOARD = ReplyKeyboardMarkup(
    [["‚úèÔ∏è Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ"], ["üíî ŸÑÿ∫Ÿà ÿπÿ∂Ÿà€åÿ™ ÿßÿ≤ ÿ®ÿßÿ¥⁄ØÿßŸá"], ["üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å"]], resize_keyboard=True # "ÿ™⁄©ŸÖ€åŸÑ ŸÜÿßŸÖ" ÿ®Ÿá "Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ" ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ
)
CANCEL_MEMBERSHIP_CONFIRMATION_KEYBOARD = ReplyKeyboardMarkup(
    [["‚úÖ ÿ®ŸÑŸáÿå ÿπÿ∂Ÿà€åÿ™ŸÖ ŸÑÿ∫Ÿà ÿ¥ŸàÿØ"], ["‚ùå ÿÆ€åÿ±ÿå ŸÖŸÜÿµÿ±ŸÅ ÿ¥ÿØŸÖ"]], resize_keyboard=True, one_time_keyboard=True
)
NAME_EDIT_BACK_KEYBOARD = ReplyKeyboardMarkup( # ⁄©€åÿ®Ÿàÿ±ÿØ ÿ®ÿ±ÿß€å ÿßŸÜÿµÿ±ÿßŸÅ ÿßÿ≤ Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ
    [["üîô ÿßŸÜÿµÿ±ÿßŸÅ Ÿà ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ"]], resize_keyboard=True, one_time_keyboard=True
)

HEALTH_TIPS_FOR_CLUB = [
    "ÿ±Ÿàÿ≤ÿßŸÜŸá ÿ≠ÿØÿßŸÇŸÑ €∏ ŸÑ€åŸàÿßŸÜ ÿ¢ÿ® ÿ®ŸÜŸàÿ¥€åÿØ ÿ™ÿß ÿ®ÿØŸÜÿ™ÿßŸÜ Ÿá€åÿØÿ±ÿßÿ™Ÿá ÿ®ŸÖÿßŸÜÿØ.",
    "ÿÆŸàÿßÿ® ⁄©ÿßŸÅ€å (€∑-€∏ ÿ≥ÿßÿπÿ™) ÿ®ÿ±ÿß€å ÿ®ÿßÿ≤€åÿßÿ®€å ÿßŸÜÿ±⁄ò€å Ÿà ÿ≥ŸÑÿßŸÖÿ™ ÿ±ŸàÿßŸÜ ÿ∂ÿ±Ÿàÿ±€å ÿßÿ≥ÿ™.",
    "ÿ≠ÿØÿßŸÇŸÑ €≥€∞ ÿØŸÇ€åŸÇŸá ŸÅÿπÿßŸÑ€åÿ™ ÿ®ÿØŸÜ€å ŸÖÿ™Ÿàÿ≥ÿ∑ ÿØÿ± ÿ®€åÿ¥ÿ™ÿ± ÿ±Ÿàÿ≤Ÿáÿß€å ŸáŸÅÿ™Ÿá ÿ®Ÿá ÿ≠ŸÅÿ∏ ÿ≥ŸÑÿßŸÖÿ™ ŸÇŸÑÿ® ⁄©ŸÖ⁄© ŸÖ€å‚Äå⁄©ŸÜÿØ."
]

# --- ÿ™Ÿàÿßÿ®ÿπ ÿØ€åÿ™ÿßÿ®€åÿ≥ ---
def get_or_create_user_profile(user_id: str, username: str = None, first_name: str = None) -> dict:
    if not db:
        logger.warning(f"DB: Firestore client (db) is None. Profile for user {user_id} will be in-memory mock.")
        return {"user_id": user_id, "username": username, "first_name": first_name, "age": None, "gender": None, 
                "is_club_member": False, "points": 0, "badges": [], "club_tip_usage_count": 0, 
                "club_join_date": None, "name_first_db": None, "name_last_db": None, 
                "full_profile_completion_points_awarded": False} # ŸÜÿßŸÖ ŸÅ€åŸÑÿØ ÿßŸÖÿ™€åÿßÿ≤ ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØ

    user_ref = db.collection('users').document(user_id)
    try: user_doc = user_ref.get()
    except Exception as e:
        logger.error(f"DB: ÿÆÿ∑ÿß ŸáŸÜ⁄ØÿßŸÖ get() ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id}: {e}", exc_info=True)
        return {"user_id": user_id, "username": username, "first_name": first_name, "age": None, "gender": None, "is_club_member": False, "points": 0, "badges": [], "club_tip_usage_count": 0, "club_join_date": None, "name_first_db": None, "name_last_db": None, "full_profile_completion_points_awarded": False}

    default_fields = {'age': None, 'gender': None, 'is_club_member': False, 'points': 0, 'badges': [], 
                      'club_tip_usage_count': 0, 'club_join_date': None, 'name_first_db': None, 
                      'name_last_db': None, 'full_profile_completion_points_awarded': False}

    if user_doc.exists:
        user_data = user_doc.to_dict()
        needs_update_in_db = False
        for key, default_value in default_fields.items():
            if key not in user_data:
                user_data[key] = default_value
                needs_update_in_db = True
        if needs_update_in_db:
             update_payload = {k:v for k,v in default_fields.items() if k not in user_doc.to_dict()}
             if update_payload:
                try: user_ref.update(update_payload)
                except Exception as e_update: logger.error(f"DB: ÿÆÿ∑ÿß ÿØÿ± ÿ¢ŸæÿØ€åÿ™ ŸÅ€åŸÑÿØŸáÿß€å Ÿæ€åÿ¥ ŸÅÿ±ÿ∂ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id}: {e_update}")
        return user_data
    else:
        user_data = {'user_id': user_id, 'username': username, 'first_name': first_name, 
                     'registration_date': firestore.SERVER_TIMESTAMP, 'last_interaction_date': firestore.SERVER_TIMESTAMP}
        for key, default_value in default_fields.items(): user_data[key] = default_value
        try: user_ref.set(user_data)
        except Exception as e_set: logger.error(f"DB: ÿÆÿ∑ÿß ÿØÿ± ÿß€åÿ¨ÿßÿØ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id}: {e_set}")
        return user_data

def update_user_profile_data(user_id: str, data_to_update: dict) -> None:
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±)
    if not db: return
    user_ref = db.collection('users').document(user_id)
    data_to_update['last_updated_date'] = firestore.SERVER_TIMESTAMP
    try:
        user_ref.update(data_to_update)
        logger.info(f"DB: Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id} ÿ®ÿß ÿØÿßÿØŸá‚ÄåŸáÿß€å {data_to_update} ÿØÿ± Firestore ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØ.")
    except Exception as e:
        logger.error(f"DB: ÿÆÿ∑ÿß ÿØÿ± ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id} ÿ®ÿß ÿØÿßÿØŸá‚ÄåŸáÿß€å {data_to_update}: {e}", exc_info=True)


def get_user_profile_data(user_id: str) -> dict | None:
    # ... (ÿ®ÿß ŸÅ€åŸÑÿØ full_profile_completion_points_awarded)
    if not db: return None
    user_ref = db.collection('users').document(user_id)
    try:
        user_doc = user_ref.get()
        if user_doc.exists:
            user_data = user_doc.to_dict()
            defaults = {'is_club_member': False, 'points': 0, 'badges': [], 'club_tip_usage_count': 0, 
                        'club_join_date': None, 'age': None, 'gender': None, 'name_first_db': None, 
                        'name_last_db': None, 'full_profile_completion_points_awarded': False}
            for key, default_value in defaults.items():
                if key not in user_data: user_data[key] = default_value
            return user_data
    except Exception as e:
        logger.error(f"DB: ÿÆÿ∑ÿß ÿØÿ± ÿÆŸàÿßŸÜÿØŸÜ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id}: {e}", exc_info=True)
    return None


# --- ÿ™Ÿàÿßÿ®ÿπ ⁄©ŸÖ⁄©€å ÿ±ÿ®ÿßÿ™ ---
async def ask_openrouter(system_prompt: str, chat_history: list, model_override: str = None) -> str:
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±)
    headers = {"Authorization": f"Bearer {OPENROUTER_API_KEY}", "Content-Type": "application/json"}
    messages_payload = [{"role": "system", "content": system_prompt}] + chat_history
    current_model = model_override if model_override else OPENROUTER_MODEL_NAME
    body = {"model": current_model, "messages": messages_payload, "temperature": 0.5}
    logger.info(f"ÿ¢ŸÖÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ OpenRouter. ŸÖÿØŸÑ: {current_model}, ÿ™ÿßÿ±€åÿÆ⁄ÜŸá: {len(chat_history)}.")
    async with httpx.AsyncClient(timeout=90.0) as client:
        try:
            resp = await client.post("https://openrouter.ai/api/v1/chat/completions", headers=headers, json=body)
            resp.raise_for_status()
            data = resp.json()
            if data.get("choices") and data["choices"][0].get("message") and data["choices"][0]["message"].get("content"):
                llm_response_content = data["choices"][0]["message"]["content"].strip()
                logger.info(f"Ÿæÿßÿ≥ÿÆ LLM ({current_model}): '{llm_response_content}'")
                return llm_response_content
            logger.error(f"ÿ≥ÿßÿÆÿ™ÿßÿ± Ÿæÿßÿ≥ÿÆ OpenRouter ({current_model}) ŸÜÿßŸÖÿπÿ™ÿ®ÿ±: {data}")
            return "‚ùå ŸÖÿ¥⁄©ŸÑ€å ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ Ÿæÿßÿ≥ÿÆ ÿßÿ≤ ÿ≥ÿ±Ÿà€åÿ≥ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å ÿ±ÿÆ ÿØÿßÿØ."
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ™ÿ®ÿßÿ∑ OpenRouter ({current_model}): {e}", exc_info=True)
            return "‚ùå ÿ®ÿ±Ÿàÿ≤ ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ÿ≥ÿ±Ÿà€åÿ≥ ŸáŸàÿ¥ ŸÖÿµŸÜŸàÿπ€å."

def _prepare_doctor_system_prompt(age: int, gender: str) -> str:
    # Ÿæÿ±ÿßŸÖŸæÿ™ ÿßÿµŸÑÿßÿ≠ ÿ¥ÿØŸá Ÿà ⁄©Ÿàÿ™ÿßŸá‚Äåÿ™ÿ± ÿ®ÿ±ÿß€å ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá
    return (
        f"ÿ¥ŸÖÿß 'ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá'ÿå €å⁄© Ÿæÿ≤ÿ¥⁄© ÿπŸÖŸàŸÖ€å ŸÖÿ™ÿÆÿµÿµÿå ÿØŸÇ€åŸÇ Ÿà ÿ®ÿß ÿ≠ŸàÿµŸÑŸá Ÿáÿ≥ÿ™€åÿØ. ⁄©ÿßÿ±ÿ®ÿ±€å ⁄©Ÿá ÿ®ÿß ÿ¥ŸÖÿß ÿµÿ≠ÿ®ÿ™ ŸÖ€å‚Äå⁄©ŸÜÿØ {age} ÿ≥ÿßŸÑŸá Ÿà {gender} ÿßÿ≥ÿ™. "
        "Ÿàÿ∏€åŸÅŸá ÿßÿµŸÑ€å ÿ¥ŸÖÿß Ÿæÿßÿ≥ÿÆ⁄ØŸà€å€å ÿØŸÇ€åŸÇ Ÿà ÿπŸÑŸÖ€å ÿ®Ÿá ÿ≥ŸàÿßŸÑÿßÿ™ Ÿæÿ≤ÿ¥⁄©€å ⁄©ÿßÿ±ÿ®ÿ± ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ŸÅÿßÿ±ÿ≥€å ÿ≥ÿßÿØŸá Ÿà ŸÇÿßÿ®ŸÑ ŸÅŸáŸÖ ÿßÿ≥ÿ™. "
        "ÿß⁄Øÿ± ÿ≥ŸàÿßŸÑ ⁄©ÿßÿ±ÿ®ÿ± ÿ®ÿ±ÿß€å ÿßÿ±ÿßÿ¶Ÿá Ÿæÿßÿ≥ÿÆ ⁄©ÿßŸÖŸÑ Ÿà ÿß€åŸÖŸÜÿå ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ®€åÿ¥ÿ™ÿ±€å ÿØÿßÿ¥ÿ™ÿå **ŸÅŸÇÿ∑ €å⁄© €åÿß ÿØŸà ÿ≥ŸàÿßŸÑ ⁄©Ÿàÿ™ÿßŸáÿå ⁄©ŸÑ€åÿØ€å Ÿà ⁄©ÿßŸÖŸÑÿßŸã ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®Ÿæÿ±ÿ≥€åÿØ** ÿ™ÿß ÿ¨ÿ≤ÿ¶€åÿßÿ™ ŸÑÿßÿ≤ŸÖ ÿ±ÿß ⁄©ÿ≥ÿ® ⁄©ŸÜ€åÿØ. ÿßÿ≤ Ÿæÿ±ÿ≥€åÿØŸÜ ÿ≥ŸàÿßŸÑÿßÿ™ ÿ∫€åÿ±ÿ∂ÿ±Ÿàÿ±€å €åÿß ŸÑ€åÿ≥ÿ™ ÿ®ŸÑŸÜÿØ ÿ≥ŸàÿßŸÑÿßÿ™ ÿÆŸàÿØÿØÿßÿ±€å ⁄©ŸÜ€åÿØ. "
        "Ÿæÿ≥ ÿßÿ≤ ÿØÿ±€åÿßŸÅÿ™ ÿßÿ∑ŸÑÿßÿπÿßÿ™ ⁄©ÿßŸÅ€åÿå ÿ±ÿßŸáŸÜŸÖÿß€å€å Ÿæÿ≤ÿ¥⁄©€å ÿπŸÖŸàŸÖ€å Ÿà ÿßŸàŸÑ€åŸá ÿßÿ±ÿßÿ¶Ÿá ÿØŸá€åÿØ. **Ÿáÿ±⁄Øÿ≤ ÿ™ÿ¥ÿÆ€åÿµ ŸÇÿ∑ÿπ€å ŸÜÿØŸá€åÿØ €åÿß ÿØÿßÿ±Ÿà ÿ™ÿ¨Ÿà€åÿ≤ ŸÜ⁄©ŸÜ€åÿØ.** "
        "ŸáŸÖ€åÿ¥Ÿá ÿ™ÿß⁄©€åÿØ ⁄©ŸÜ€åÿØ ⁄©Ÿá ÿ®ÿ±ÿß€å ÿ™ÿ¥ÿÆ€åÿµ ŸÇÿ∑ÿπ€å Ÿà ÿØÿ±ŸÖÿßŸÜ ÿ™ÿÆÿµÿµ€åÿå ÿ®ÿß€åÿØ ÿ®Ÿá Ÿæÿ≤ÿ¥⁄© ŸÖÿ±ÿßÿ¨ÿπŸá ⁄©ŸÜŸÜÿØÿå ÿÆÿµŸàÿµÿßŸã ÿß⁄Øÿ± ÿπŸÑÿßÿ¶ŸÖ ÿ¥ÿØ€åÿØ €åÿß ÿ∑ŸàŸÑÿßŸÜ€å‚ÄåŸÖÿØÿ™ Ÿáÿ≥ÿ™ŸÜÿØ. "
        "ÿß⁄Øÿ± ÿ≥ŸàÿßŸÑ€å ⁄©ÿßŸÖŸÑÿßŸã ÿ∫€åÿ±Ÿæÿ≤ÿ¥⁄©€å ÿ®ŸàÿØ (ŸÖÿßŸÜŸÜÿØ ÿ¢ÿ¥Ÿæÿ≤€åÿå ÿ™ÿßÿ±€åÿÆ Ÿà ...)ÿå ÿ®ÿß ÿßÿ≠ÿ™ÿ±ÿßŸÖ Ÿà ÿ®ÿß ÿß€åŸÜ ÿπÿ®ÿßÿ±ÿ™ Ÿæÿßÿ≥ÿÆ ÿØŸá€åÿØ: 'ŸÖÿ™ÿßÿ≥ŸÅŸÖÿå ŸÖŸÜ €å⁄© ÿ±ÿ®ÿßÿ™ Ÿæÿ≤ÿ¥⁄© Ÿáÿ≥ÿ™ŸÖ Ÿà ŸÅŸÇÿ∑ ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÖ ÿ®Ÿá ÿ≥ŸàÿßŸÑÿßÿ™ ŸÖÿ±ÿ™ÿ®ÿ∑ ÿ®ÿß ÿ≠Ÿàÿ≤Ÿá Ÿæÿ≤ÿ¥⁄©€å Ÿæÿßÿ≥ÿÆ ÿØŸáŸÖ. ⁄Üÿ∑Ÿàÿ± ŸÖ€å‚Äåÿ™ŸàÿßŸÜŸÖ ÿØÿ± ÿ≤ŸÖ€åŸÜŸá Ÿæÿ≤ÿ¥⁄©€å ÿ®Ÿá ÿ¥ŸÖÿß ⁄©ŸÖ⁄© ⁄©ŸÜŸÖÿü' "
        "ÿØÿ± ÿ™ŸÖÿßŸÖ€å Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß€å ÿÆŸàÿØÿå ŸÖÿ≥ÿ™ŸÇ€åŸÖÿßŸã ÿ®Ÿá ÿ≥ÿ±ÿßÿ∫ ÿßÿµŸÑ ŸÖÿ∑ŸÑÿ® ÿ®ÿ±Ÿà€åÿØ Ÿà ÿßÿ≤ ŸÖŸÇÿØŸÖÿßÿ™ ÿ∫€åÿ±ÿ∂ÿ±Ÿàÿ±€å (ŸÖÿßŸÜŸÜÿØ 'ÿ®ŸÑŸá'ÿå 'ÿÆÿ®') Ÿæÿ±Ÿá€åÿ≤ ⁄©ŸÜ€åÿØ. "
        "ŸÑÿ≠ŸÜ ÿ¥ŸÖÿß ÿ®ÿß€åÿØ ÿ≠ÿ±ŸÅŸá‚Äåÿß€åÿå ŸáŸÖÿØŸÑÿßŸÜŸá Ÿà ŸÖÿ≠ÿ™ÿ±ŸÖÿßŸÜŸá ÿ®ÿßÿ¥ÿØÿå ÿßŸÖÿß ÿßÿ≤ ÿπÿ®ÿßÿ±ÿßÿ™ ÿ®€åÿ¥ ÿßÿ≤ ÿ≠ÿØ ÿßÿ≠ÿ≥ÿßÿ≥€å €åÿß ÿ¥ÿπÿßÿ±€å ÿÆŸàÿØÿØÿßÿ±€å ⁄©ŸÜ€åÿØ."
    )

async def notify_points_awarded(bot: Application.bot, chat_id: int, user_id_str: str, points_awarded: int, reason: str):
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±)
    if not db: return
    try:
        await asyncio.to_thread(get_or_create_user_profile, user_id_str) 
        user_profile_updated = await asyncio.to_thread(get_user_profile_data, user_id_str)
        total_points = user_profile_updated.get('points', 0) if user_profile_updated else points_awarded
        message = f"‚ú® ÿ¥ŸÖÿß {points_awarded} ÿßŸÖÿ™€åÿßÿ≤ ÿ®ÿ±ÿß€å '{reason}' ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿ±ÿØ€åÿØ!\nŸÖÿ¨ŸÖŸàÿπ ÿßŸÖÿ™€åÿßÿ≤ ÿ¥ŸÖÿß ÿß⁄©ŸÜŸàŸÜ: {total_points} ÿßÿ≥ÿ™. üåü"
        await bot.send_message(chat_id=chat_id, text=message)
        logger.info(f"ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿßŸÖÿ™€åÿßÿ≤ ÿ®Ÿá {user_id_str} ÿ®ÿ±ÿß€å '{reason}'. ÿßŸÖÿ™€åÿßÿ≤: {points_awarded}, ŸÖÿ¨ŸÖŸàÿπ: {total_points}")
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ∑ŸÑÿßÿπ‚Äåÿ±ÿ≥ÿßŸÜ€å ÿßŸÖÿ™€åÿßÿ≤ ÿ®Ÿá {user_id_str}: {e}", exc_info=True)

async def award_badge_if_not_already_awarded(bot: Application.bot, chat_id: int, user_id_str: str, badge_name: str):
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±)
    if not db: return
    try:
        user_profile = await asyncio.to_thread(get_user_profile_data, user_id_str)
        if user_profile:
            current_badges = user_profile.get('badges', [])
            if badge_name not in current_badges:
                await asyncio.to_thread(update_user_profile_data, user_id_str, {'badges': firestore.ArrayUnion([badge_name])})
                await bot.send_message(chat_id=chat_id, text=f"üèÜ ÿ™ÿ®ÿ±€å⁄©! ÿ¥ŸÖÿß ŸÜÿ¥ÿßŸÜ '{badge_name}' ÿ±ÿß ÿØÿ±€åÿßŸÅÿ™ ⁄©ÿ±ÿØ€åÿØ!")
                logger.info(f"ŸÜÿ¥ÿßŸÜ '{badge_name}' ÿ®Ÿá ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿßÿπÿ∑ÿß ÿ¥ÿØ.")
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿπÿ∑ÿß€å ŸÜÿ¥ÿßŸÜ '{badge_name}' ÿ®Ÿá {user_id_str}: {e}", exc_info=True)


async def get_dynamic_main_menu_keyboard(context: ContextTypes.DEFAULT_TYPE, user_id_str: str) -> ReplyKeyboardMarkup:
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±)
    is_member = False
    if 'is_club_member_cached' in context.user_data:
        is_member = context.user_data['is_club_member_cached']
    elif db:
        try:
            user_profile = await asyncio.to_thread(get_user_profile_data, user_id_str)
            is_member = user_profile.get('is_club_member', False) if user_profile else False
            context.user_data['is_club_member_cached'] = is_member
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿÆŸàÿßŸÜÿØŸÜ Ÿàÿ∂ÿπ€åÿ™ ÿπÿ∂Ÿà€åÿ™ ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} (get_dynamic_main_menu): {e}")
            is_member = False 
    else: context.user_data['is_club_member_cached'] = False
    if is_member:
        keyboard_layout = [["üë®‚Äç‚öïÔ∏è ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá", "üì¶ ÿ±ÿßŸáŸÜŸÖÿß€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™"], ["üë§ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿà ÿ®ÿßÿ¥⁄ØÿßŸá"], ["üì£ ŸÜ⁄©ÿ™Ÿá ÿ≥ŸÑÿßŸÖÿ™€å ÿ®ÿßÿ¥⁄ØÿßŸá"]]
    else:
        keyboard_layout = [["üë®‚Äç‚öïÔ∏è ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá", "üì¶ ÿ±ÿßŸáŸÜŸÖÿß€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™"], ["‚≠ê ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ÿ™ÿßŸÅÿ™Ÿá"]]
    return ReplyKeyboardMarkup(keyboard_layout, resize_keyboard=True)

# --- ⁄©ŸÜÿ™ÿ±ŸÑ‚Äå⁄©ŸÜŸÜÿØŸá‚ÄåŸáÿß€å ÿßÿµŸÑ€å ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    # ... (ŸÖŸÜÿ∑ŸÇ Ÿæÿß⁄©ÿ≥ÿßÿ≤€å user_data Ÿà ÿßÿ±ÿ≥ÿßŸÑ ŸÖŸÜŸà€å ŸæŸà€åÿß ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±) ...
    user = update.effective_user
    user_id_str = str(user.id) 
    message_prefix = "ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ŸÑÿ∫Ÿà ÿ¥ŸÖÿß ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ. " if context.user_data.get('_is_cancel_flow', False) else ""
    if context.user_data.get('_is_cancel_flow', False): del context.user_data['_is_cancel_flow']
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ({user.full_name or user.username}) /start €åÿß ÿ®ÿßÿ≤⁄Øÿ¥ÿ™/ŸÑÿ∫Ÿà ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å.")
    keys_to_clear_from_session = ["doctor_chat_history", "system_prompt_for_doctor", "age_temp", "is_club_member_cached", "awaiting_field_to_edit", "temp_first_name", "profile_completion_flow_active", "club_join_after_profile_flow"]
    for key in keys_to_clear_from_session:
        if key in context.user_data: del context.user_data[key]
    logger.info(f"ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ¨ŸÑÿ≥Ÿá (user_data) ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ÿ¥ÿØ.")
    if db: 
        try: await asyncio.to_thread(get_or_create_user_profile, user_id_str, user.username, user.first_name)
        except Exception as e: logger.error(f"ÿÆÿ∑ÿß ÿØÿ± get_or_create_user_profile (start) ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id_str}: {e}", exc_info=True)
    dynamic_main_menu = await get_dynamic_main_menu_keyboard(context, user_id_str)
    welcome_message_text = f"ÿ≥ŸÑÿßŸÖ {user.first_name or '⁄©ÿßÿ±ÿ®ÿ±'}! üëã\nŸÖŸÜ ÿ±ÿ®ÿßÿ™ ÿ™ÿßŸÅÿ™Ÿá Ÿáÿ≥ÿ™ŸÖ. ŸÑÿ∑ŸÅÿßŸã €å⁄©€å ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ:"
    if message_prefix: welcome_message_text = message_prefix + "ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€åÿØ."
    effective_chat_id = update.effective_chat.id
    try:
        is_direct_start_command = update.message and update.message.text == "/start"
        is_photo_present_in_message = hasattr(update.message, 'photo') and update.message.photo is not None
        if is_direct_start_command and not is_photo_present_in_message : 
            await context.bot.send_photo(chat_id=effective_chat_id, photo=WELCOME_IMAGE_URL, caption=welcome_message_text, reply_markup=dynamic_main_menu)
        else: 
            await context.bot.send_message(chat_id=effective_chat_id, text=welcome_message_text, reply_markup=dynamic_main_menu)
    except Exception as e:
        logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ ÿÆŸàÿ¥‚Äåÿ¢ŸÖÿØ⁄ØŸà€å€å ÿ®ÿ±ÿß€å {user_id_str}: {e}", exc_info=True)
        await context.bot.send_message(chat_id=effective_chat_id, text=welcome_message_text, reply_markup=dynamic_main_menu)
    return States.MAIN_MENU

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±) ...
    user = update.effective_user
    user_id = user.id if user else "Unknown"
    logger.info(f"User {user_id} called /cancel. Delegating to start handler.")
    context.user_data['_is_cancel_flow'] = True
    if update.effective_chat:
        await context.bot.send_message(chat_id=update.effective_chat.id, text="ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ ÿ¥ŸÖÿß ŸÑÿ∫Ÿà ÿ¥ÿØ. ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å...", reply_markup=ReplyKeyboardRemove())
    return await start(update, context)


async def main_menu_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    text = update.message.text
    user = update.effective_user
    user_id_str = str(user.id)
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿØÿ± ŸÖŸÜŸà€å ÿßÿµŸÑ€å ⁄Øÿ≤€åŸÜŸá '{text}' ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØ.")
    dynamic_main_menu = await get_dynamic_main_menu_keyboard(context, user_id_str)

    if text == "üë®‚Äç‚öïÔ∏è ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá":
        context.user_data['profile_completion_flow_active'] = True # ÿ®ÿ±ÿß€å ÿØ⁄©ÿ™ÿ± ŸáŸÖ ŸÜ€åÿßÿ≤ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿæÿß€åŸá ÿØÿßÿ±€åŸÖ
        context.user_data['club_join_after_profile_flow'] = False # ÿßÿ≤ ŸÖÿ≥€åÿ± ÿØ⁄©ÿ™ÿ± ÿ¢ŸÖÿØŸáÿå ŸÜŸá ÿπÿ∂Ÿà€åÿ™ ÿ®ÿßÿ¥⁄ØÿßŸá
        
        age, gender, name_first, name_last = None, None, None, None
        if db:
            try:
                user_profile = await asyncio.to_thread(get_user_profile_data, user_id_str)
                if user_profile:
                    age = user_profile.get("age")
                    gender = user_profile.get("gender")
                    name_first = user_profile.get("name_first_db")
                    name_last = user_profile.get("name_last_db")
            except Exception as e:
                logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿÆŸàÿßŸÜÿØŸÜ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} (ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá): {e}", exc_info=True)

        if age and gender and name_first and name_last: # ÿß⁄Øÿ± Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿßÿ≥ÿ™
            logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿØÿßÿ±ÿØ. ŸÖÿ≥ÿ™ŸÇ€åŸÖ ÿ®Ÿá ŸÖ⁄©ÿßŸÑŸÖŸá ÿ®ÿß ÿØ⁄©ÿ™ÿ±.")
            system_prompt = _prepare_doctor_system_prompt(age, gender)
            context.user_data["system_prompt_for_doctor"] = system_prompt
            context.user_data["doctor_chat_history"] = []
            await update.message.reply_text(
                f"ŸÖÿ¥ÿÆÿµÿßÿ™ ÿ¥ŸÖÿß (ŸÜÿßŸÖ: {name_first} {name_last}, ÿ≥ŸÜ: {age}ÿå ÿ¨ŸÜÿ≥€åÿ™: {gender}) ÿßÿ≤ ŸÇÿ®ŸÑ ŸÖŸàÿ¨ŸàÿØ ÿßÿ≥ÿ™.\n"
                "ÿß⁄©ŸÜŸàŸÜ ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ ÿ≥ŸàÿßŸÑ Ÿæÿ≤ÿ¥⁄©€å ÿÆŸàÿØ ÿ±ÿß ÿßÿ≤ ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá ÿ®Ÿæÿ±ÿ≥€åÿØ.",
                reply_markup=DOCTOR_CONVERSATION_KEYBOARD
            )
            return States.DOCTOR_CONVERSATION
        else: # ÿß⁄Øÿ± Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ŸÜ€åÿ≥ÿ™ÿå ÿ®Ÿá ÿ™ÿ±ÿ™€åÿ® ÿ≥ŸàÿßŸÑ ÿ¥ŸàÿØ
            logger.info(f"Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ⁄©ÿßŸÖŸÑ ŸÜ€åÿ≥ÿ™. ÿ¥ÿ±Ÿàÿπ ŸÅÿ±ÿ¢€åŸÜÿØ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ.")
            await update.message.reply_text("ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ®Ÿá€åŸÜŸá ÿßÿ≤ ÿÆÿØŸÖÿßÿ™ÿå ŸÑÿ∑ŸÅÿßŸã ÿßÿ®ÿ™ÿØÿß Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿÆŸàÿØ ÿ±ÿß ÿ™⁄©ŸÖ€åŸÑ ⁄©ŸÜ€åÿØ.\nŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
                                            reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
            return States.AWAITING_PROFILE_FIRST_NAME
            
    elif text == "üì¶ ÿ±ÿßŸáŸÜŸÖÿß€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™":
        # ... (ÿ®ÿØŸàŸÜ ÿ™ÿ∫€å€åÿ±) ...
        keyboard = [[InlineKeyboardButton("ŸÖÿ¥ÿßŸáÿØŸá Ÿàÿ®‚Äåÿ≥ÿß€åÿ™ ÿ™ÿßŸÅÿ™Ÿá", url=URL_TAFTEH_WEBSITE)]]
        reply_markup_inline = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("ÿ®ÿ±ÿß€å ŸÖÿ¥ÿßŸáÿØŸá ŸÖÿ≠ÿµŸàŸÑÿßÿ™ Ÿà Ÿàÿ®‚Äåÿ≥ÿß€åÿ™ ÿ™ÿßŸÅÿ™Ÿá...", reply_markup=reply_markup_inline)
        return States.MAIN_MENU
        
    elif text == "‚≠ê ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ÿ™ÿßŸÅÿ™Ÿá": # ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ±ÿßŸÜ ÿ∫€åÿ±ÿπÿ∂Ÿà
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ⁄Øÿ≤€åŸÜŸá 'ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ÿ™ÿßŸÅÿ™Ÿá' ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ÿ±ÿØ.")
        age, gender, name_first, name_last = None, None, None, None
        if db:
            user_profile = await asyncio.to_thread(get_user_profile_data, user_id_str)
            if user_profile:
                age = user_profile.get("age")
                gender = user_profile.get("gender")
                name_first = user_profile.get("name_first_db")
                name_last = user_profile.get("name_last_db")
        
        if not (age and gender and name_first and name_last): # ÿß⁄Øÿ± Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ŸÜ€åÿ≥ÿ™
            logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿ®ÿ±ÿß€å ÿπÿ∂Ÿà€åÿ™ ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿØÿßÿ±ÿØ.")
            context.user_data['profile_completion_flow_active'] = True
            context.user_data['club_join_after_profile_flow'] = True # Ÿæÿ≥ ÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑÿå ÿ®Ÿá ÿπÿ∂Ÿà€åÿ™ ÿ®ÿßÿ¥⁄ØÿßŸá ÿ®ÿ±Ÿà
            await update.message.reply_text(
                "ÿ®ÿ±ÿß€å ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸáÿå ÿßÿ®ÿ™ÿØÿß ÿ®ÿß€åÿØ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿÆŸàÿØ ÿ±ÿß ÿ™⁄©ŸÖ€åŸÑ ⁄©ŸÜ€åÿØ.\n"
                "ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:",
                reply_markup=PROFILE_INPUT_BACK_KEYBOARD
            )
            return States.AWAITING_PROFILE_FIRST_NAME
        else: # Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿßÿ≥ÿ™ÿå Ÿæÿ≥ ÿ≥ŸàÿßŸÑ ÿ®ÿ±ÿß€å ÿ™ÿß€å€åÿØ ÿπÿ∂Ÿà€åÿ™
            await update.message.reply_text(
                "ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ŸÖÿ¥ÿ™ÿ±€åÿßŸÜ ÿ™ÿßŸÅÿ™Ÿá ŸÖÿ≤ÿß€åÿß€å Ÿà€å⁄òŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿ¥ŸÖÿß ÿÆŸàÿßŸáÿØ ÿØÿßÿ¥ÿ™! ÿ¢€åÿß ŸÖÿß€åŸÑ ÿ®Ÿá ÿπÿ∂Ÿà€åÿ™ Ÿáÿ≥ÿ™€åÿØÿü",
                reply_markup=CLUB_JOIN_CONFIRMATION_KEYBOARD
            )
            return States.AWAITING_CLUB_JOIN_CONFIRMATION
        
    elif text == "üë§ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿà ÿ®ÿßÿ¥⁄ØÿßŸá": 
        return await my_profile_info_handler(update, context)
    elif text == "üì£ ŸÜ⁄©ÿ™Ÿá ÿ≥ŸÑÿßŸÖÿ™€å ÿ®ÿßÿ¥⁄ØÿßŸá": 
        return await health_tip_command_handler(update, context)
    else: 
        await update.message.reply_text("⁄Øÿ≤€åŸÜŸá ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™.", reply_markup=dynamic_main_menu)
        return States.MAIN_MENU

# --- ⁄©ŸÜÿ™ÿ±ŸÑ‚Äå⁄©ŸÜŸÜÿØŸá‚ÄåŸáÿß€å ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ÿ¨ÿ±€åÿßŸÜ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ---
async def awaiting_profile_first_name_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    text = update.message.text.strip()
    user = update.effective_user
    user_id_str = str(user.id)

    if text == "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å":
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ (ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄©) ÿßŸÜÿµÿ±ÿßŸÅ ÿØÿßÿØ Ÿà ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™.")
        if 'profile_completion_flow_active' in context.user_data: del context.user_data['profile_completion_flow_active']
        if 'club_join_after_profile_flow' in context.user_data: del context.user_data['club_join_after_profile_flow']
        return await start(update, context)

    if not text or len(text) < 2 or len(text) > 50:
        await update.message.reply_text("ŸÜÿßŸÖ Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿµÿ≠€åÿ≠ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ.", reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
        return States.AWAITING_PROFILE_FIRST_NAME
    
    context.user_data['temp_profile_first_name'] = text
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ŸÖŸàŸÇÿ™ '{text}' ÿ±ÿß ÿ®ÿ±ÿß€å Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ.")
    await update.message.reply_text("ŸÖÿ™ÿ¥⁄©ÿ±ŸÖ. ÿ≠ÿßŸÑÿß ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (€åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ):", reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
    return States.AWAITING_PROFILE_LAST_NAME

async def awaiting_profile_last_name_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    text = update.message.text.strip()
    user = update.effective_user
    user_id_str = str(user.id)

    if text == "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å":
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ (ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å) ÿßŸÜÿµÿ±ÿßŸÅ ÿØÿßÿØ Ÿà ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™.")
        if 'temp_profile_first_name' in context.user_data: del context.user_data['temp_profile_first_name']
        if 'profile_completion_flow_active' in context.user_data: del context.user_data['profile_completion_flow_active']
        if 'club_join_after_profile_flow' in context.user_data: del context.user_data['club_join_after_profile_flow']
        return await start(update, context)

    if not text or len(text) < 2 or len(text) > 50:
        await update.message.reply_text("ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿµÿ≠€åÿ≠ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ.", reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
        return States.AWAITING_PROFILE_LAST_NAME

    context.user_data['temp_profile_last_name'] = text
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ŸÖŸàŸÇÿ™ '{text}' ÿ±ÿß ÿ®ÿ±ÿß€å Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ.")
    await update.message.reply_text("ÿπÿßŸÑ€å! ÿ≠ÿßŸÑÿß ŸÑÿ∑ŸÅÿßŸã ÿ≥ŸÜ ÿÆŸàÿØ ÿ±ÿß ÿ®Ÿá ÿπÿØÿØ Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (€åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ):", reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
    return States.AWAITING_PROFILE_AGE

async def awaiting_profile_age_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    text = update.message.text.strip()
    if text == "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å":
        logger.info(f"User {update.effective_user.id} returned to main menu from AWAITING_PROFILE_AGE.")
        for key in ['temp_profile_first_name', 'temp_profile_last_name', 'profile_completion_flow_active', 'club_join_after_profile_flow']:
            if key in context.user_data: del context.user_data[key]
        return await start(update, context)
    
    age_text = text
    user = update.effective_user
    user_id_str = str(user.id)
    if not age_text.isdigit() or not (1 <= int(age_text) <= 120):
        await update.message.reply_text("‚ùóÔ∏è ŸÑÿ∑ŸÅÿßŸã €å⁄© ÿ≥ŸÜ ŸÖÿπÿ™ÿ®ÿ± (ÿπÿØÿØ ÿ®€åŸÜ €± ÿ™ÿß €±€≤€∞) Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ.", reply_markup=PROFILE_INPUT_BACK_KEYBOARD)
        return States.AWAITING_PROFILE_AGE
    
    context.user_data["temp_profile_age"] = int(age_text)
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿ≥ŸÜ ŸÖŸàŸÇÿ™ ÿÆŸàÿØ ÿ±ÿß {age_text} ÿ®ÿ±ÿß€å Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ.")
    await update.message.reply_text("ÿ®ÿ≥€åÿßÿ± ÿÆŸàÿ®. ÿØÿ± ŸÜŸáÿß€åÿ™ÿå ŸÑÿ∑ŸÅÿßŸã ÿ¨ŸÜÿ≥€åÿ™ ÿÆŸàÿØ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ (€åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ):", reply_markup=PROFILE_GENDER_SELECTION_KEYBOARD)
    return States.AWAITING_PROFILE_GENDER

async def awaiting_profile_gender_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    text = update.message.text.strip()
    if text == "üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å":
        logger.info(f"User {update.effective_user.id} returned to main menu from AWAITING_PROFILE_GENDER.")
        for key in ['temp_profile_first_name', 'temp_profile_last_name', 'temp_profile_age', 'profile_completion_flow_active', 'club_join_after_profile_flow']:
            if key in context.user_data: del context.user_data[key]
        return await start(update, context)

    gender_input = text
    user = update.effective_user
    user_id_str = str(user.id)

    first_name = context.user_data.pop('temp_profile_first_name', None)
    last_name = context.user_data.pop('temp_profile_last_name', None)
    age = context.user_data.pop('temp_profile_age', None)
    
    if not (first_name and last_name and age):
        logger.error(f"ÿÆÿ∑ÿß: ÿßÿ∑ŸÑÿßÿπÿßÿ™ ŸÜÿßŸÇÿµ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿØÿ± ŸÖÿ±ÿ≠ŸÑŸá ŸÜŸáÿß€å€å ÿ™⁄©ŸÖ€åŸÑ.")
        await update.message.reply_text("ŸÖÿ¥⁄©ŸÑ€å ÿØÿ± ⁄Øÿ±ÿØÿ¢Ÿàÿ±€å ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ¥ŸÖÿß Ÿæ€åÿ¥ ÿ¢ŸÖÿØ. ŸÑÿ∑ŸÅÿßŸã ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß ÿ™ŸÑÿßÿ¥ ⁄©ŸÜ€åÿØ.", reply_markup=await get_dynamic_main_menu_keyboard(context, user_id_str))
        return await start(update, context)
    
    gender = gender_input
    awarded_full_profile_points_badge = False
    if db:
        try:
            user_profile_before_update = await asyncio.to_thread(get_user_profile_data, user_id_str)
            update_payload = {"name_first_db": first_name, "name_last_db": last_name, "age": age, "gender": gender}
            
            if user_profile_before_update and not user_profile_before_update.get('profile_name_completion_points_awarded', False): # ÿß⁄Øÿ± ŸÇÿ®ŸÑÿß ÿßŸÖÿ™€åÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ ŸÜÿßŸÖ ÿ±ÿß ŸÜ⁄Øÿ±ŸÅÿ™Ÿá
                update_payload["points"] = firestore.Increment(POINTS_FOR_NAME_COMPLETION) # ÿß€åŸÜÿ¨ÿß POINTS_FOR_FULL_PROFILE_COMPLETION
                update_payload["profile_name_completion_points_awarded"] = True # ÿß€åŸÜ Ÿæÿ±⁄ÜŸÖ ÿ®ÿ±ÿß€å ŸÜÿßŸÖ Ÿà ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å
                awarded_full_profile_points_badge = True
            
            # ÿ®ÿ±ÿ±ÿ≥€å Ÿà ÿßÿπÿ∑ÿß€å ÿßŸÖÿ™€åÿßÿ≤ ÿ®ÿ±ÿß€å ÿßŸàŸÑ€åŸÜ ÿ™⁄©ŸÖ€åŸÑ ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™ (ÿß⁄Øÿ± ŸÇÿ®ŸÑÿß ÿØÿßÿØŸá ŸÜÿ¥ÿØŸá)
            if user_profile_before_update and not user_profile_before_update.get('profile_completion_points_awarded', False):
                if (user_profile_before_update.get("age") is None or user_profile_before_update.get("gender") is None):
                    if "points" not in update_payload: update_payload["points"] = firestore.Increment(POINTS_FOR_PROFILE_COMPLETION)
                    else: update_payload["points"] = firestore.Increment(POINTS_FOR_PROFILE_COMPLETION + POINTS_FOR_NAME_COMPLETION if awarded_full_profile_points_and_badge else POINTS_FOR_PROFILE_COMPLETION) # ÿ™ÿ¨ŸÖ€åÿπ ÿßŸÖÿ™€åÿßÿ≤
                    update_payload["profile_completion_points_awarded"] = True
                    # ŸÜÿ¥ÿßŸÜ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿæÿß€åŸá ŸáŸÖ ÿß€åŸÜÿ¨ÿß ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ ÿß⁄Øÿ± ŸÇÿ®ŸÑÿß ÿØÿßÿØŸá ŸÜÿ¥ÿØŸá
                    # awarded_full_profile_points_badge ÿ®Ÿá ÿß€åŸÜ ŸÖÿπŸÜ€å ÿßÿ≥ÿ™ ⁄©Ÿá Ÿáÿ± ÿØŸà ŸÜŸàÿπ ÿ™⁄©ŸÖ€åŸÑ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØŸá


            await asyncio.to_thread(update_user_profile_data, user_id_str, update_payload)
            logger.info(f"Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} (ŸÜÿßŸÖ: {first_name} {last_name}, ÿ≥ŸÜ: {age}, ÿ¨ŸÜÿ≥€åÿ™: {gender}) ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ.")
            
            if awarded_full_profile_points_badge: # ÿß⁄Øÿ± ÿßŸÖÿ™€åÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ ŸÜÿßŸÖ ÿØÿßÿØŸá ÿ¥ÿØ
                 logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} Ÿàÿßÿ¨ÿØ ÿ¥ÿ±ÿß€åÿ∑ ÿØÿ±€åÿßŸÅÿ™ ÿßŸÖÿ™€åÿßÿ≤ Ÿà ŸÜÿ¥ÿßŸÜ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ÿßÿ≥ÿ™.")
            elif awarded_profile_points_and_badge: # ÿß⁄Øÿ± ŸÅŸÇÿ∑ ÿßŸÖÿ™€åÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ ÿ≥ŸÜ/ÿ¨ŸÜÿ≥€åÿ™ ÿØÿßÿØŸá ÿ¥ÿØ
                 logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} Ÿàÿßÿ¨ÿØ ÿ¥ÿ±ÿß€åÿ∑ ÿØÿ±€åÿßŸÅÿ™ ÿßŸÖÿ™€åÿßÿ≤ Ÿà ŸÜÿ¥ÿßŸÜ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿæÿß€åŸá ÿßÿ≥ÿ™.")


        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ €åÿß ÿßÿπÿ∑ÿß€å ÿßŸÖÿ™€åÿßÿ≤/ŸÜÿ¥ÿßŸÜ ÿ®ÿ±ÿß€å {user_id_str}: {e}", exc_info=True)

    # ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± user_data ÿ®ÿ±ÿß€å ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿØÿ± ŸáŸÖ€åŸÜ ÿ¨ŸÑÿ≥Ÿá ÿß⁄Øÿ± ŸÑÿßÿ≤ŸÖ ÿ¥ÿØ (ŸÖÿ´ŸÑÿß ÿ®ÿ±ÿß€å ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá)
    context.user_data["age"] = age 
    context.user_data["gender"] = gender
    context.user_data["name_first_db"] = first_name
    context.user_data["name_last_db"] = last_name


    await update.message.reply_text(
        f"‚úÖ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ¥ŸÖÿß ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ™⁄©ŸÖ€åŸÑ ÿ¥ÿØ:\n"
        f"ŸÜÿßŸÖ: {first_name} {last_name}\n"
        f"ÿ≥ŸÜ: {age}\n"
        f"ÿ¨ŸÜÿ≥€åÿ™: {gender}",
        reply_markup=ReplyKeyboardRemove() # ÿ≠ÿ∞ŸÅ ⁄©€åÿ®Ÿàÿ±ÿØ ŸÇÿ®ŸÑ€å
    )

    if awarded_full_profile_points_badge: # ÿß⁄Øÿ± ÿßŸÖÿ™€åÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ ŸÜÿßŸÖ ÿØÿßÿØŸá ÿ¥ÿØÿå ŸÜÿ¥ÿßŸÜ ⁄©ÿßŸÖŸÑ ŸáŸÖ ÿØÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ
        await notify_points_awarded(update.get_bot(), update.effective_chat.id, user_id_str, POINTS_FOR_NAME_COMPLETION + (POINTS_FOR_PROFILE_COMPLETION if not user_profile_before_update.get('profile_completion_points_awarded') else 0), "ÿ™⁄©ŸÖ€åŸÑ ⁄©ÿßŸÖŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ")
        await award_badge_if_not_already_awarded(update.get_bot(), update.effective_chat.id, user_id_str, BADGE_FULL_PROFILE)
        if not user_profile_before_update.get('profile_completion_points_awarded'): # ÿß⁄Øÿ± ŸÜÿ¥ÿßŸÜ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿæÿß€åŸá ŸáŸÖ ŸÜ⁄Øÿ±ŸÅÿ™Ÿá ÿ®ŸàÿØ
             await award_badge_if_not_already_awarded(update.get_bot(), update.effective_chat.id, user_id_str, BADGE_PROFILE_COMPLETE)
    elif awarded_profile_points_and_badge: # ÿß⁄Øÿ± ŸÅŸÇÿ∑ ÿßŸÖÿ™€åÿßÿ≤ ÿ™⁄©ŸÖ€åŸÑ ÿ≥ŸÜ/ÿ¨ŸÜÿ≥€åÿ™ ÿØÿßÿØŸá ÿ¥ÿØ
        await notify_points_awarded(update.get_bot(), update.effective_chat.id, user_id_str, POINTS_FOR_PROFILE_COMPLETION, "ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ (ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™)")
        await award_badge_if_not_already_awarded(update.get_bot(), update.effective_chat.id, user_id_str, BADGE_PROFILE_COMPLETE)


    if context.user_data.pop('club_join_after_profile_flow', False):
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ±ÿß ÿ™⁄©ŸÖ€åŸÑ ⁄©ÿ±ÿØÿå ŸáÿØÿß€åÿ™ ÿ®Ÿá ÿ™ÿß€å€åÿØ ÿπÿ∂Ÿà€åÿ™ ÿ®ÿßÿ¥⁄ØÿßŸá.")
        await update.message.reply_text(
            "ÿß⁄©ŸÜŸàŸÜ ⁄©Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ¥ŸÖÿß ⁄©ÿßŸÖŸÑ ÿ¥ÿØÿå ÿ®ÿ±ÿß€å ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ŸÖÿ¥ÿ™ÿ±€åÿßŸÜ ÿ™ÿß€å€åÿØ ŸÜŸáÿß€å€å ÿ±ÿß ÿßŸÜÿ¨ÿßŸÖ ÿØŸá€åÿØ:",
            reply_markup=CLUB_JOIN_CONFIRMATION_KEYBOARD
        )
        return States.AWAITING_CLUB_JOIN_CONFIRMATION
    else: # ÿß⁄Øÿ± ÿßÿ≤ ŸÖÿ≥€åÿ± ÿØ€å⁄Øÿ±€å ÿ¢ŸÖÿØŸá ÿ®ŸàÿØ (ŸÖÿ´ŸÑÿß ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá €åÿß Ÿà€åÿ±ÿß€åÿ¥ Ÿæÿ±ŸàŸÅÿß€åŸÑ)
        # await update.message.reply_text("ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿßÿ≤⁄Øÿ¥ÿ™€åÿØ.", reply_markup=await get_dynamic_main_menu_keyboard(context, user_id_str))
        return await start(update, context) # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å ÿ®ÿß ŸÖŸÜŸà€å ÿµÿ≠€åÿ≠


# --- ⁄©ŸÜÿ™ÿ±ŸÑ‚Äå⁄©ŸÜŸÜÿØŸá‚ÄåŸáÿß€å ÿØ€å⁄Øÿ± (handle_club_join_confirmation, doctor_conversation_handler, my_profile_info_handler, profile_view_handler, handle_cancel_membership_confirmation, awaiting_first_name_handler (ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥), awaiting_last_name_handler (ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥), health_tip_command_handler, fallback_message, Flask) ŸÖÿßŸÜŸÜÿØ ŸÇÿ®ŸÑ ÿ®ÿß ÿßÿµŸÑÿßÿ≠ÿßÿ™ ÿ¨ÿ≤ÿ¶€å ÿØÿ± ÿ¨ÿ±€åÿßŸÜ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ Ÿà Ÿæ€åÿßŸÖ‚ÄåŸáÿß ---
# ... (⁄©ÿØ ÿß€åŸÜ ÿ™Ÿàÿßÿ®ÿπ ⁄©Ÿá ŸÇÿ®ŸÑÿßŸã ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØŸá Ÿà ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ®ÿßÿ≤ÿ®€åŸÜ€å Ÿà ÿßÿµŸÑÿßÿ≠ÿßÿ™ ÿ¨ÿ≤ÿ¶€å ÿØÿ± ÿ¨ÿ±€åÿßŸÜ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà €åÿß Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿØÿßÿ±ŸÜÿØ) ...

# --- ⁄©ŸÜÿ™ÿ±ŸÑ‚Äå⁄©ŸÜŸÜÿØŸá‚ÄåŸáÿß€å Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ (ŸÇÿ®ŸÑÿß awaiting_first_name_handler Ÿà awaiting_last_name_handler ÿ®ŸàÿØŸÜÿØÿå ÿ≠ÿßŸÑÿß ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ)
async def edit_first_name_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    # ÿß€åŸÜ ŸáŸÖÿßŸÜ awaiting_first_name_handler ŸÇÿ®ŸÑ€å ÿßÿ≥ÿ™ÿå ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ
    user = update.effective_user
    user_id_str = str(user.id)
    text = update.message.text.strip()

    if text == "üîô ÿßŸÜÿµÿ±ÿßŸÅ Ÿà ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ":
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿßÿ≤ Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ ÿßŸÜÿµÿ±ÿßŸÅ ÿØÿßÿØ.")
        return await my_profile_info_handler(update, context) 

    if not text or len(text) < 2 or len(text) > 50: 
        await update.message.reply_text("ŸÜÿßŸÖ Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿµÿ≠€åÿ≠ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß ÿßŸÜÿµÿ±ÿßŸÅ ÿØŸá€åÿØ.", reply_markup=NAME_INPUT_KEYBOARD)
        return States.AWAITING_EDIT_FIRST_NAME # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸáŸÖ€åŸÜ ÿ≠ÿßŸÑÿ™
    
    context.user_data['temp_edit_first_name'] = text
    logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ŸÖŸàŸÇÿ™ ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ '{text}' ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ÿ±ÿØ.")
    await update.message.reply_text("ŸÖÿ™ÿ¥⁄©ÿ±ŸÖ. ÿ≠ÿßŸÑÿß ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿ¨ÿØ€åÿØ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (€åÿß ÿ®ÿ±ÿß€å ÿßŸÜÿµÿ±ÿßŸÅÿå ⁄Øÿ≤€åŸÜŸá ÿ≤€åÿ± ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ):", reply_markup=NAME_INPUT_KEYBOARD)
    return States.AWAITING_EDIT_LAST_NAME

async def edit_last_name_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    # ÿß€åŸÜ ŸáŸÖÿßŸÜ awaiting_last_name_handler ŸÇÿ®ŸÑ€å ÿßÿ≥ÿ™ÿå ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ
    user = update.effective_user
    user_id_str = str(user.id)
    last_name_text = update.message.text.strip()

    if last_name_text == "üîô ÿßŸÜÿµÿ±ÿßŸÅ Ÿà ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ":
        logger.info(f"⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿßÿ≤ Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿßŸÜÿµÿ±ÿßŸÅ ÿØÿßÿØ.")
        if 'temp_edit_first_name' in context.user_data: del context.user_data['temp_edit_first_name']
        return await my_profile_info_handler(update, context)

    if not last_name_text or len(last_name_text) < 2 or len(last_name_text) > 50: 
        await update.message.reply_text("ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å Ÿàÿßÿ±ÿØ ÿ¥ÿØŸá ŸÖÿπÿ™ÿ®ÿ± ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿµÿ≠€åÿ≠ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ €åÿß ÿßŸÜÿµÿ±ÿßŸÅ ÿØŸá€åÿØ.", reply_markup=NAME_INPUT_KEYBOARD)
        return States.AWAITING_EDIT_LAST_NAME # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸáŸÖ€åŸÜ ÿ≠ÿßŸÑÿ™

    first_name = context.user_data.pop('temp_edit_first_name', None)
    if not first_name:
        logger.error(f"ÿÆÿ∑ÿß: ŸÜÿßŸÖ ⁄©Ÿà⁄Ü⁄© ŸÖŸàŸÇÿ™ ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ÿ®ÿ±ÿß€å ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
        await update.message.reply_text("ŸÖÿ¥⁄©ŸÑ€å ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿßÿ∑ŸÑÿßÿπÿßÿ™ Ÿæ€åÿ¥ ÿ¢ŸÖÿØÿå ŸÑÿ∑ŸÅÿßŸã ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ±ÿß Ÿà€åÿ±ÿß€åÿ¥ ⁄©ŸÜ€åÿØ.")
        return await my_profile_info_handler(update, context) 

    # ÿ®ÿ±ÿß€å Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖÿå ÿßŸÖÿ™€åÿßÿ≤ Ÿà ŸÜÿ¥ÿßŸÜ ÿ¨ÿØ€åÿØ€å ÿØÿ± ŸÜÿ∏ÿ± ŸÜŸÖ€å‚Äå⁄Ø€åÿ±€åŸÖ ŸÖ⁄Øÿ± ÿß€åŸÜ⁄©Ÿá ÿ®ÿÆŸàÿßŸá€åÿØ
    if db:
        try:
            update_payload = {"name_first_db": first_name, "name_last_db": last_name_text}
            await asyncio.to_thread(update_user_profile_data, user_id_str, update_payload)
            logger.info(f"ŸÜÿßŸÖ ⁄©ÿßÿ±ÿ®ÿ± {user_id_str} ÿ®Ÿá ({first_name} {last_name_text}) ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØ.")
            await update.message.reply_text(f"ŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá '{first_name} {last_name_text}' ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØ.")
        except Exception as e:
            logger.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜÿßŸÖ/ŸÜÿßŸÖ ÿÆÿßŸÜŸàÿßÿØ⁄Ø€å ÿ®ÿ±ÿß€å {user_id_str}: {e}", exc_info=True)
            await update.message.reply_text("ŸÖÿ¥⁄©ŸÑ€å ÿØÿ± ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÜÿßŸÖ ÿ¥ŸÖÿß Ÿæ€åÿ¥ ÿ¢ŸÖÿØ.")
    else:
        await update.message.reply_text(f"ŸÜÿßŸÖ ÿ¥ŸÖÿß ÿ®Ÿá '{first_name} {last_name_text}' ÿ™ŸÜÿ∏€åŸÖ ÿ¥ÿØ (ÿ∞ÿÆ€åÿ±Ÿá‚Äåÿ≥ÿßÿ≤€å ÿØ€åÿ™ÿßÿ®€åÿ≥ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™).")
        
    return await my_profile_info_handler(update, context) # ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÜŸÖÿß€åÿ¥ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ®ÿß ÿßÿ∑ŸÑÿßÿπÿßÿ™ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ ÿ¥ÿØŸá


# --- ÿ®ŸÑŸà⁄© ÿßÿµŸÑ€å ÿ®ÿ±ŸÜÿßŸÖŸá ---
if __name__ == '__main__':
    logger.info("ÿ®ŸÑŸà⁄© ÿßÿµŸÑ€å ÿ®ÿ±ŸÜÿßŸÖŸá ÿ¢ÿ∫ÿßÿ≤ ÿ¥ÿØ.")
    if db is None:
        logger.warning("*"*65 + "\n* ÿØ€åÿ™ÿßÿ®€åÿ≥ Firestore ŸÖŸÇÿØÿßÿ±ÿØŸá€å ÿßŸàŸÑ€åŸá ŸÜÿ¥ÿØŸá! ÿ±ÿ®ÿßÿ™ ÿ®ÿß ŸÇÿßÿ®ŸÑ€åÿ™ ŸÖÿ≠ÿØŸàÿØ ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ. *\n" + "*"*65)

    flask_thread = threading.Thread(target=run_flask_app, name="FlaskThread", daemon=True)
    flask_thread.start()
    logger.info("ÿ™ÿ±ÿØ Flask ÿ¥ÿ±Ÿàÿπ ÿ®Ÿá ⁄©ÿßÿ± ⁄©ÿ±ÿØ.")

    telegram_application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            States.MAIN_MENU: [MessageHandler(filters.Regex("^(üë®‚Äç‚öïÔ∏è ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá|üì¶ ÿ±ÿßŸáŸÜŸÖÿß€å ŸÖÿ≠ÿµŸàŸÑÿßÿ™|‚≠ê ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá ÿ™ÿßŸÅÿ™Ÿá|üë§ Ÿæÿ±ŸàŸÅÿß€åŸÑ Ÿà ÿ®ÿßÿ¥⁄ØÿßŸá|üì£ ŸÜ⁄©ÿ™Ÿá ÿ≥ŸÑÿßŸÖÿ™€å ÿ®ÿßÿ¥⁄ØÿßŸá)$"), main_menu_handler)],
            
            # ÿ¨ÿ±€åÿßŸÜ ÿ™⁄©ŸÖ€åŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿßŸàŸÑ€åŸá (ÿß⁄Øÿ± ÿßÿ≤ "ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá" €åÿß "ÿπÿ∂Ÿà€åÿ™ ÿØÿ± ÿ®ÿßÿ¥⁄ØÿßŸá" ÿ¢ŸÖÿØŸá Ÿà Ÿæÿ±ŸàŸÅÿß€åŸÑ ŸÜÿßŸÇÿµ ÿßÿ≥ÿ™)
            States.AWAITING_PROFILE_FIRST_NAME: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.TEXT & ~filters.COMMAND, awaiting_profile_first_name_handler)],
            States.AWAITING_PROFILE_LAST_NAME: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.TEXT & ~filters.COMMAND, awaiting_profile_last_name_handler)],
            States.AWAITING_PROFILE_AGE: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.TEXT & ~filters.COMMAND, awaiting_profile_age_handler)],
            States.AWAITING_PROFILE_GENDER: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.Regex("^(ÿ≤ŸÜ|ŸÖÿ±ÿØ)$"), awaiting_profile_gender_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: u.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ÿ®ÿß ÿØ⁄©ŸÖŸá ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ.",reply_markup=PROFILE_GENDER_SELECTION_KEYBOARD))],
            
            # ÿ¨ÿ±€åÿßŸÜ Ÿàÿ±ŸàÿØ ÿ≥ŸÜ Ÿà ÿ¨ŸÜÿ≥€åÿ™ ŸÅŸÇÿ∑ ÿ®ÿ±ÿß€å ÿØ⁄©ÿ™ÿ± ÿ™ÿßŸÅÿ™Ÿá (ÿß⁄Øÿ± Ÿæÿ±ŸàŸÅÿß€åŸÑ ⁄©ÿßŸÖŸÑ ŸÜ€åÿ≥ÿ™ ÿßŸÖÿß ŸÜÿÆŸàÿßŸá€åŸÖ ŸÜÿßŸÖ ÿ±ÿß ÿ®Ÿæÿ±ÿ≥€åŸÖ)
            States.AWAITING_DOCTOR_AGE: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.TEXT & ~filters.COMMAND, request_age_handler)], # ŸÜÿßŸÖ ÿ™ÿßÿ®ÿπ request_age_handler ÿ™ÿ∫€å€åÿ± ⁄©ÿ±ÿØŸá ÿ®ŸàÿØ
            States.AWAITING_DOCTOR_GENDER: [MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), MessageHandler(filters.Regex("^(ÿ≤ŸÜ|ŸÖÿ±ÿØ)$"), request_gender_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: u.message.reply_text("ŸÑÿ∑ŸÅÿßŸã ÿ®ÿß ÿØ⁄©ŸÖŸá ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ €åÿß ÿ®ÿßÿ≤⁄Øÿ±ÿØ€åÿØ.",reply_markup=GENDER_SELECTION_KEYBOARD))],
            
            States.DOCTOR_CONVERSATION: [MessageHandler(filters.Regex("^(‚ùì ÿ≥ŸàÿßŸÑ ÿ¨ÿØ€åÿØ ÿßÿ≤ ÿØ⁄©ÿ™ÿ±|üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å)$"), doctor_conversation_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, doctor_conversation_handler)],
            States.AWAITING_CLUB_JOIN_CONFIRMATION: [MessageHandler(filters.Regex("^(‚úÖ ÿ®ŸÑŸáÿå ÿπÿ∂Ÿà ŸÖ€å‚Äåÿ¥ŸàŸÖ|‚ùå ÿÆ€åÿ±ÿå ŸÅÿπŸÑÿßŸã ŸÜŸá)$"), handle_club_join_confirmation), MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: u.message.reply_text("ÿ®ÿß ÿØ⁄©ŸÖŸá‚ÄåŸáÿß Ÿæÿßÿ≥ÿÆ ÿØŸá€åÿØ.",reply_markup=CLUB_JOIN_CONFIRMATION_KEYBOARD))],
            
            States.PROFILE_VIEW: [MessageHandler(filters.Regex("^(‚úèÔ∏è ÿ™⁄©ŸÖ€åŸÑ/Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ|üíî ŸÑÿ∫Ÿà ÿπÿ∂Ÿà€åÿ™ ÿßÿ≤ ÿ®ÿßÿ¥⁄ØÿßŸá|üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å)$"), profile_view_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: u.message.reply_text("⁄Øÿ≤€åŸÜŸá Ÿæÿ±ŸàŸÅÿß€åŸÑ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.",reply_markup=PROFILE_VIEW_KEYBOARD))],
            States.AWAITING_CANCEL_MEMBERSHIP_CONFIRMATION: [MessageHandler(filters.Regex("^(‚úÖ ÿ®ŸÑŸáÿå ÿπÿ∂Ÿà€åÿ™ŸÖ ŸÑÿ∫Ÿà ÿ¥ŸàÿØ|‚ùå ÿÆ€åÿ±ÿå ŸÖŸÜÿµÿ±ŸÅ ÿ¥ÿØŸÖ)$"), handle_cancel_membership_confirmation), MessageHandler(filters.TEXT & ~filters.COMMAND, lambda u,c: u.message.reply_text("ÿ®ÿß ÿØ⁄©ŸÖŸá‚ÄåŸáÿß Ÿæÿßÿ≥ÿÆ ÿØŸá€åÿØ.",reply_markup=CANCEL_MEMBERSHIP_CONFIRMATION_KEYBOARD))],
            
            # ÿ¨ÿ±€åÿßŸÜ Ÿà€åÿ±ÿß€åÿ¥ ŸÜÿßŸÖ ÿßÿ≤ ÿØÿßÿÆŸÑ Ÿæÿ±ŸàŸÅÿß€åŸÑ
            States.AWAITING_EDIT_FIRST_NAME: [MessageHandler(filters.Regex("^üîô ÿßŸÜÿµÿ±ÿßŸÅ Ÿà ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ$"), profile_view_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, edit_first_name_handler)],
            States.AWAITING_EDIT_LAST_NAME: [MessageHandler(filters.Regex("^üîô ÿßŸÜÿµÿ±ÿßŸÅ Ÿà ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá Ÿæÿ±ŸàŸÅÿß€åŸÑ$"), profile_view_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, edit_last_name_handler)],
        },
        fallbacks=[
            CommandHandler("cancel", cancel), 
            CommandHandler("start", start),
            MessageHandler(filters.Regex("^üîô ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸÖŸÜŸà€å ÿßÿµŸÑ€å$"), start), # ŸÅÿßŸÑ ÿ®⁄© ÿπŸÖŸàŸÖ€å
        ],
        persistent=False, name="main_conversation", allow_reentry=True
    )
    
    telegram_application.add_handler(CommandHandler("myprofile", my_profile_info_handler))
    telegram_application.add_handler(CommandHandler("clubtip", health_tip_command_handler))
    telegram_application.add_handler(conv_handler)
    telegram_application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, fallback_message))
    
    logger.info("ÿ±ÿ®ÿßÿ™ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿØÿ± ÿ≠ÿßŸÑ ÿ¥ÿ±Ÿàÿπ polling...")
    try:
        telegram_application.run_polling(allowed_updates=Update.ALL_TYPES)
    except Exception as e:
        logger.critical(f"ÿÆÿ∑ÿß€å ŸÖÿ±⁄Øÿ®ÿßÿ± ÿØÿ± run_polling: {e}", exc_info=True)
    finally:
        logger.info("ÿ®ÿ±ŸÜÿßŸÖŸá ÿØÿ± ÿ≠ÿßŸÑ ÿÆÿßÿ™ŸÖŸá ÿßÿ≥ÿ™.")